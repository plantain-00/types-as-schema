import { TypeDeclaration, Type, Parameter, EnumType, StringDeclaration, EnumDeclaration, getReferencesInType } from './utils'

export function generateGraphqlRootType(declarations: TypeDeclaration[], getReferenceTypeImports: (referenceTypes: ReferenceType[]) => string) {
  const rootTypes: string[] = []
  const nonRootTypes: string[] = []
  const resolveResults: string[] = []
  const referenceTypes: ReferenceType[] = []

  let remainDeclarations = [...declarations]
  const declarationsWithParameters: string[] = []
  let tmp: TypeDeclaration[] = []
  for (; ;) {
    for (const d of remainDeclarations) {
      if (d.kind === 'object') {
        if (d.members.some((m) => m.parameters)) {
          declarationsWithParameters.push(d.name)
        } else if (d.members.some((m) => getReferencesInType(m.type).some((r) => declarationsWithParameters.includes(r.name)))) {
          declarationsWithParameters.push(d.name)
        } else {
          tmp.push(d)
        }
      } else if (d.kind === 'reference') {
        if (declarationsWithParameters.includes(d.name)) {
          declarationsWithParameters.push(d.newName)
        } else {
          tmp.push(d)
        }
      } else if (d.kind === 'union') {
        if (d.members.some((m) => getReferencesInType(m).some((r) => declarationsWithParameters.includes(r.name)))) {
          declarationsWithParameters.push(d.name)
        } else {
          tmp.push(d)
        }
      } else {
        tmp.push(d)
      }
    }
    if (tmp.length == remainDeclarations.length) {
      break
    }
    remainDeclarations = tmp
    tmp = []
  }
  console.info(declarationsWithParameters)

  for (const typeDeclaration of declarations) {
    if (typeDeclaration.kind === 'object') {
      const isQueryOrMutation = typeDeclaration.name === 'Query' || typeDeclaration.name === 'Mutation'
      if (isQueryOrMutation) {
        for (const member of typeDeclaration.members) {
          const memberType = getMemberType(member.type, referenceTypes, declarations, declarationsWithParameters)
          const parameters = getMemberParameters(referenceTypes, declarations, declarationsWithParameters, member.parameters)
          rootTypes.push(`  ${member.name}(${parameters}, context: TContext, info: GraphQLResolveInfo): ${memberType} | Promise<${memberType}>`)
          resolveResults.push(`  ${member.name}: DeepReturnType<${memberType}>`)
        }
      } else {
        const nonRootTypeMembers: string[] = []
        for (const member of typeDeclaration.members) {
          const memberType = getMemberType(member.type, referenceTypes, declarations, declarationsWithParameters)
          const optionalToken = member.optional ? '?' : ''
          if (member.parameters) {
            const parameters = getMemberParameters(referenceTypes, declarations, declarationsWithParameters, member.parameters)
            nonRootTypeMembers.push(`  ${member.name}${optionalToken}(${parameters}, context: TContext, info: GraphQLResolveInfo): ${memberType} | Promise<${memberType}>`)
          } else {
            nonRootTypeMembers.push(`  ${member.name}${optionalToken}: ${memberType}`)
          }
        }
        const generic = declarationsWithParameters.includes(typeDeclaration.name) ? '<TContext>' : ''
        nonRootTypes.push(`export interface ${typeDeclaration.name}${generic} {
${nonRootTypeMembers.join('\n')}
}`)
      }
    } else if (typeDeclaration.kind === 'reference') {
      const generic = declarationsWithParameters.includes(typeDeclaration.name) ? '<TContext>' : ''
      nonRootTypes.push(`export type ${typeDeclaration.newName}${generic} = ${typeDeclaration.name}${generic}`)
    } else if (typeDeclaration.kind === 'union') {
      const generic = declarationsWithParameters.includes(typeDeclaration.name) ? '<TContext>' : ''
      const memberType = getMemberType(typeDeclaration, referenceTypes, declarations, declarationsWithParameters)
      nonRootTypes.push(`export type ${typeDeclaration.name}${generic} = ${memberType}`)
    } else if (typeDeclaration.kind === 'string') {
      if (typeDeclaration.enums && !isNativeType(typeDeclaration.name)) {
        referenceTypes.push(typeDeclaration)
      }
    } else if (typeDeclaration.kind === 'enum') {
      referenceTypes.push(typeDeclaration)
    }
  }
  const referenceTypeImports = getReferenceTypeImports(referenceTypes)
  return `/**
 * This file is generated by 'types-as-schema'
 * It is not mean to be edited by hand
 */
// tslint:disable
/* eslint-disable */

import { GraphQLResolveInfo } from 'graphql'

${referenceTypeImports}

export interface Root<TContext> {
${rootTypes.join('\n')}
}

${nonRootTypes.join('\n\n')}

export type DeepReturnType<T> = {
  [P in keyof T]: T[P] extends Array<infer U>
    ? Array<DeepReturnType<U>>
    : T[P] extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepReturnType<U>>
      : T[P] extends (...args: any[]) => infer R
        ? R extends Promise<infer U>
          ? U
          : R
        : DeepReturnType<T[P]>
}

export interface ResolveResult<TContext> {
${resolveResults.join('\n')}
}

/* eslint-enable */
// tslint:enable
`
}

export type ReferenceType = EnumType | StringDeclaration | EnumDeclaration

function getMemberParameters(referenceTypes: ReferenceType[], declarations: TypeDeclaration[], declarationsWithParameters: string[], parameters?: Parameter[]) {
  if (parameters && parameters.length > 0) {
    const parameterString = parameters.map((parameter) => {
      const optionalToken = parameter.optional ? '?' : ''
      const parameterType = getMemberType(parameter.type, referenceTypes, declarations, declarationsWithParameters)
      return `${parameter.name}${optionalToken}: ${parameterType}`
    }).join(', ')
    return `input: { ${parameterString} }`
  }
  return 'input: {}'
}

function isNativeType(typeName: string) {
  return typeName === 'string' || typeName === 'number' || typeName === 'boolean'
}

function getMemberType(memberType: Type, referenceTypes: ReferenceType[], declarations: TypeDeclaration[], declarationsWithParameters: string[]): string {
  if (memberType.kind === 'array') {
    return `Array<${getMemberType(memberType.type, referenceTypes, declarations, declarationsWithParameters)}>`
  }
  if (memberType.kind === 'enum') {
    if (!isNativeType(memberType.name)) {
      referenceTypes.push(memberType)
    }
    return memberType.name
  }
  if (memberType.kind === 'reference') {
    const declaration = declarations.find((d) => d.name === memberType.name)
    if (declaration && (declaration.kind === 'enum' || (declaration.kind === 'string' && declaration.enums))) {
      return memberType.name
    }
    if (declarationsWithParameters.includes(memberType.name)) {
      return memberType.name + '<TContext>'
    }
    return memberType.name
  }
  if (memberType.kind === 'map') {
    const mapKeyType = getMemberType(memberType.key, referenceTypes, declarations, declarationsWithParameters)
    const mapValueType = getMemberType(memberType.value, referenceTypes, declarations, declarationsWithParameters)
    return `{ [name: ${mapKeyType}]: ${mapValueType} }`
  }
  if (memberType.kind === 'union') {
    return memberType.members.map((member) => getMemberType(member, referenceTypes, declarations, declarationsWithParameters)).join(' | ')
  }
  if (memberType.kind === undefined) {
    return 'any'
  }
  return memberType.kind
}
