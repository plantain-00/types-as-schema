import * as path from 'path'

import { TypeDeclaration, Type, MemberParameter, EnumType, StringDeclaration, EnumDeclaration } from './utils'

// tslint:disable-next-line:cognitive-complexity
export function generateGraphqlRootType(declarations: TypeDeclaration[], graphqlRootTypePath: string) {
  const rootTypes: string[] = []
  const nonRootTypes: string[] = []
  const resolveResults: string[] = []
  const resolvers: string[] = []
  const referenceTypes: ReferenceType[] = []
  for (const typeDeclaration of declarations) {
    if (typeDeclaration.kind === 'object') {
      const isQueryOrMutation = typeDeclaration.name === 'Query' || typeDeclaration.name === 'Mutation'
      if (isQueryOrMutation) {
        for (const member of typeDeclaration.members) {
          const memberType = getMemberType(member.type, referenceTypes, declarations)
          const parameters = getMemberParameters(referenceTypes, declarations, member.parameters)
          rootTypes.push(`  ${member.name}(${parameters}, context: TContext, info: GraphQLResolveInfo): DeepPromisifyReturnType<${memberType}> | Promise<DeepPromisifyReturnType<${memberType}>>`)
          resolveResults.push(`  ${member.name}: DeepReturnType<${memberType}>`)
        }
      } else {
        const nonRootTypeMembers: string[] = []
        for (const member of typeDeclaration.members) {
          const memberType = getMemberType(member.type, referenceTypes, declarations)
          if (member.parameters) {
            const parameters = getMemberParameters(referenceTypes, declarations, member.parameters)
            nonRootTypeMembers.push(`  ${member.name}(${parameters}, context: TContext, info: GraphQLResolveInfo): ${memberType} | Promise<${memberType}>`)
          } else {
            nonRootTypeMembers.push(`  ${member.name}: ${memberType}`)
          }
        }
        nonRootTypes.push(`export interface ${typeDeclaration.name}<TContext = any> {
${nonRootTypeMembers.join('\n')}
}`)
      }
      const resolverFields: string[] = []
      const optionalToken = isQueryOrMutation ? '' : '?'
      for (const member of typeDeclaration.members) {
        const parameters = getMemberParameters(referenceTypes, declarations, member.parameters)
        resolverFields.push(`    ${member.name}${optionalToken}(parent: any, ${parameters}, context: TContext, info: GraphQLResolveInfo): any,`)
      }
      resolvers.push(`  ${typeDeclaration.name}${optionalToken}: {
${resolverFields.join('\n')}
  },`)
    } else if (typeDeclaration.kind === 'reference') {
      nonRootTypes.push(`export type ${typeDeclaration.newName}<TContext = any> = ${typeDeclaration.name}<TContext>`)
    } else if (typeDeclaration.kind === 'union') {
      const memberType = getMemberType(typeDeclaration, referenceTypes, declarations)
      nonRootTypes.push(`export type ${typeDeclaration.name}<TContext = any> = ${memberType}`)
    } else if (typeDeclaration.kind === 'string') {
      if (typeDeclaration.enums && !isNativeType(typeDeclaration.name)) {
        referenceTypes.push(typeDeclaration)
      }
    } else if (typeDeclaration.kind === 'enum') {
      referenceTypes.push(typeDeclaration)
    }
  }
  const referenceTypeImports = getReferenceTypeImports(referenceTypes, graphqlRootTypePath)
  return `/**
 * This file is generated by 'types-as-schema'
 * It is not mean to be edited by hand
 */
// tslint:disable

import { GraphQLResolveInfo } from 'graphql'

${referenceTypeImports}

export type DeepPromisifyReturnType<T> = {
  [P in keyof T]: T[P] extends Array<infer U>
    ? Array<DeepPromisifyReturnType<U>>
    : T[P] extends (...args: infer P) => infer R
      ? (...args: P) => R | Promise<R>
      : DeepPromisifyReturnType<T[P]>
}

export type DeepReturnType<T> = {
  [P in keyof T]: T[P] extends Array<infer U>
    ? Array<DeepReturnType<U>>
    : T[P] extends (...args: any[]) => infer R
      ? R
      : DeepReturnType<T[P]>
}

export interface Root<TContext = any> {
${rootTypes.join('\n')}
}

${nonRootTypes.join('\n\n')}

export interface ApolloResolvers<TContext = any> {
${resolvers.join('\n')}
}

export interface ResolveResult<TContext = any> {
${resolveResults.join('\n')}
}

// tslint:enable
`
}

type ReferenceType = EnumType | StringDeclaration | EnumDeclaration

function getReferenceTypeImports(referenceTypes: ReferenceType[], graphqlRootTypePath: string) {
  const map: { [name: string]: string[] } = {}
  for (const referenceType of referenceTypes) {
    const file = referenceType.position.file
    if (!map[file]) {
      map[file] = []
    }
    if (map[file].every((n) => n !== referenceType.name)) {
      map[file].push(referenceType.name)
    }
  }
  const dirname = path.dirname(graphqlRootTypePath)
  const imports: string[] = []
  for (const file in map) {
    let relativePath = path.relative(dirname, file)
    if (!relativePath.startsWith('.' + path.sep) && !relativePath.startsWith('..' + path.sep)) {
      relativePath = '.' + path.sep + relativePath
    }
    relativePath = relativePath.substring(0, relativePath.length - path.extname(relativePath).length)
    imports.push(`import { ${map[file].join(', ')} } from '${relativePath}'`)
  }
  return imports.join('\n')
}

function getMemberParameters(referenceTypes: ReferenceType[], declarations: TypeDeclaration[], parameters?: MemberParameter[]) {
  if (parameters && parameters.length > 0) {
    const parameterString = parameters.map((parameter) => {
      const optionalToken = parameter.optional ? '?' : ''
      const parameterType = getMemberType(parameter.type, referenceTypes, declarations)
      return `${parameter.name}${optionalToken}: ${parameterType}`
    }).join(', ')
    return `input: { ${parameterString} }`
  }
  return 'input: {}'
}

function isNativeType(typeName: string) {
  return typeName === 'string' || typeName === 'number' || typeName === 'boolean'
}

function getMemberType(memberType: Type, referenceTypes: ReferenceType[], declarations: TypeDeclaration[]): string {
  if (memberType.kind === 'array') {
    return `Array<${getMemberType(memberType.type, referenceTypes, declarations)}>`
  }
  if (memberType.kind === 'enum') {
    if (!isNativeType(memberType.name)) {
      referenceTypes.push(memberType)
    }
    return memberType.name
  }
  if (memberType.kind === 'reference') {
    const declaration = declarations.find((d) => d.name === memberType.name)
    if (declaration && (declaration.kind === 'enum' || (declaration.kind === 'string' && declaration.enums))) {
      return memberType.name
    }
    return memberType.name + '<TContext>'
  }
  if (memberType.kind === 'map') {
    const mapKeyType = getMemberType(memberType.key, referenceTypes, declarations)
    const mapValueType = getMemberType(memberType.value, referenceTypes, declarations)
    return `{ [name: ${mapKeyType}]: ${mapValueType} }`
  }
  if (memberType.kind === 'union') {
    return memberType.members.map((member) => getMemberType(member, referenceTypes, declarations)).join(' | ')
  }
  if (memberType.kind === undefined) {
    return 'any'
  }
  return memberType.kind
}
