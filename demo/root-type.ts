/**
 * This file is generated by 'types-as-schema'
 * It is not mean to be edited by hand
 */
// tslint:disable
/* eslint-disable */

import { GraphQLResolveInfo } from 'graphql'

import { StringEnum, NumberEnum, NumberEnum2, TypeUnion9 } from './cases'

export type DeepPromisifyReturnType<T> = {
  [P in keyof T]: T[P] extends Array<infer U>
    ? Array<DeepPromisifyReturnType<U>>
    : T[P] extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPromisifyReturnType<U>>
      : T[P] extends (...args: infer P) => infer R
        ? (...args: P) => R | Promise<R>
        : DeepPromisifyReturnType<T[P]>
}

export type DeepReturnType<T> = {
  [P in keyof T]: T[P] extends Array<infer U>
    ? Array<DeepReturnType<U>>
    : T[P] extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepReturnType<U>>
      : T[P] extends (...args: any[]) => infer R
        ? R extends Promise<infer U>
          ? U
          : R
        : DeepReturnType<T[P]>
}

export interface Root<TContext = any> {
  create(input: { input: CreateInput<TContext> }, context: TContext, info: GraphQLResolveInfo): DeepPromisifyReturnType<MutationResult<TContext>> | Promise<DeepPromisifyReturnType<MutationResult<TContext>>>
  user(input: { id: string }, context: TContext, info: GraphQLResolveInfo): DeepPromisifyReturnType<GetResult<TContext>> | Promise<DeepPromisifyReturnType<GetResult<TContext>>>
  users(input: {}, context: TContext, info: GraphQLResolveInfo): DeepPromisifyReturnType<GetResult<TContext>> | Promise<DeepPromisifyReturnType<GetResult<TContext>>>
}

export interface TypeLiteral<TContext = any> {
  typeLiteralMember1: number
  typeLiteralMember2: string
}

export interface Interface<TContext = any> {
  interfaceMember1?: number
  interfaceMember2?: string
}

export interface TypeUnion1<TContext = any> {
  typeLiteralMember1?: number
  typeLiteralMember2?: string
  typeUnionMember1?: number
  typeUnionMember2?: string
}

export interface TypeUnion2<TContext = any> {
  kind: StringEnum
  typeUnionMember1?: string
  typeUnionMember2?: string
}

export interface TypeUnion3<TContext = any> {
  kind: NumberEnum
  typeUnionMember1?: string
  typeUnionMember2?: string
}

export interface TypeUnion4<TContext = any> {
  kind: string
  typeUnionMember1?: string
  typeUnionMember2?: string
}

export type TypeUnion5<TContext = any> = TypeLiteral<TContext> | Interface<TContext>

export type TypeUnion8<TContext = any> = string | string | null | boolean

export interface TypeUnion<TContext = any> {
  typeUnionMember1: TypeUnion1<TContext>
  typeUnionMember2: TypeUnion2<TContext>
  typeUnionMember3: TypeUnion3<TContext>
  typeUnionMember4: TypeUnion4<TContext>
  typeUnionMember5: TypeUnion5<TContext>
  typeUnionMember6: string | null | boolean
  typeUnionMember7: string
  typeUnionMember8: TypeUnion8<TContext>
  typeUnionMember9: TypeUnion9
}

export interface InterfaceExtends<TContext = any> {
  interfaceExtendsMember1: number
  interfaceExtendsMember2: string
  interfaceMember1?: number
  interfaceMember2?: string
}

export interface TypeIntersection1<TContext = any> {
  interfaceMember1?: number
  interfaceMember2?: string
  typeIntersectionMember1: number
  typeIntersectionMember2: string
}

export interface TypeIntersection2<TContext = any> {
  typeIntersectionMember1: number
  typeIntersectionMember2: string
  typeIntersectionMember3: number
  typeIntersectionMember4: string
}

export interface TypeIntersection<TContext = any> {
  typeIntersectionMember1: TypeIntersection1<TContext>
  typeIntersectionMember2: TypeIntersection2<TContext>
  typeIntersectionMember3: any
}

export interface TypeUnionAndIntersection<TContext = any> {
  typeIntersectionMember1: number
  kind: NumberEnum
  typeUnionMember1?: string
  typeUnionMember2?: string
}

export interface TaggedField<TContext = any> {
  taggedFieldMember1: number
  taggedFieldMember2: string
}

export interface Enum<TContext = any> {
  stringEnum: StringEnum
  numberEnum: NumberEnum
  numberEnum2: NumberEnum2
  stringEnum2: string
}

export interface NumberType<TContext = any> {
  numberMember: number
  integerMember: number
  uint32Member: number
  int32Member: number
  sint32Member: number
  fixed32Member: number
  sfixed32Member: number
  uint64Member: number
  int64Member: number
  sint64Member: number
  fixed64Member: number
  sfixed64Member: number
  floatMember: number
  doubleMember: number
  titleMember: number
}

export interface StringType<TContext = any> {
  stringMember: string
}

export interface ArrayType<TContext = any> {
  arrayType1: Array<string>
  arrayType2: Array<TypeLiteral<TContext>>
  arrayType3: Array<object>
  arrayType4: Array<number>
  arrayType5: Array<object>
  arrayType6: Array<object>
  arrayType7: Array<object>
  arrayType8: Array<object>
  arrayType9: Array<string>
  arrayType10: Array<string>
}

export interface MapType7<TContext = any> {
  foo: string
}

export interface MapType8<TContext = any> {

}

export interface MapType<TContext = any> {
  mapType: { [name: string]: number }
  mapType2: { [name: string]: TypeLiteral<TContext> }
  mapType3: { [name: string]: object }
  mapType4: { [name: string]: number }
  mapType5: { [name: string]: any }
  mapType6: object
  mapType7: MapType7<TContext>
  mapType8: MapType8<TContext>
}

export interface Parameter<TContext = any> {
  member1(input: { name: string, age: number }, context: TContext, info: GraphQLResolveInfo): string | Promise<string>
  member2(input: { name?: string }, context: TContext, info: GraphQLResolveInfo): string | Promise<string>
}

export interface DefaultValue<TContext = any> {
  stringMember: string
  numberMember: number
  booleanMember: boolean
  stringMember2: string
  stringMember3: string
  arrayMember: Array<any>
  objectMember: object
  numberMember1: number
  objectMember2: TypeLiteral<TContext>
}

export type TypeReferenceMember2<TContext = any> = TypeLiteral<TContext>

export interface ReferenceType<TContext = any> {
  typeReferenceMember1: TypeLiteral<TContext>
  typeReferenceMember2: TypeReferenceMember2<TContext>
}

export interface ClassType1<TContext = any> {
  classMember1: string
  classMember2: number
}

export interface ClassType2<TContext = any> {
  classMember3: string
  classMember4: number
  classMember1: string
  classMember2: number
}

export interface ClassType3<TContext = any> {
  classMember1: string
  classMember2: number
  classMember3: boolean
  classMember4: string
  classMember5: Array<string>
  classMember6: object
}

export interface ClassType<TContext = any> {
  classType1: ClassType1<TContext>
  classType2: ClassType2<TContext>
  classType3: ClassType3<TContext>
}

export interface Circular<TContext = any> {
  children: Array<Circular<TContext>>
}

export interface TypeAlias<TContext = any> {
  result: Result2<TContext>
}

export interface CreateInput<TContext = any> {
  member1: string
  member2: number
  member3: CreateInputMember3<TContext>
}

export interface EntryType<TContext = any> {
  optionalMember?: string
  booleanMember: boolean
  stringMember: string
  numberType: NumberType<TContext>
  arrayType: ArrayType<TContext>
  typeLiteral: object
  referenceType: ReferenceType<TContext>
  interfaceType: Interface<TContext>
  typeUnion: TypeUnion<TContext>
  interfaceExtends: InterfaceExtends<TContext>
  typeIntersection: TypeIntersection<TContext>
  typeUnionAndIntersection: TypeUnionAndIntersection<TContext>
  mapType: MapType<TContext>
  taggedField: TaggedField<TContext>
  enum: Enum<TContext>
  stringNumber: StringType<TContext>
  id: ID<TContext>
  parameter: Parameter<TContext>
  optionalArrayMember?: Array<string>
  tupleType: Array<string>
  defaultType: DefaultValue<TContext>
  anyType: any
  classType: ClassType<TContext>
  circular: Circular<TContext>
  outerType: OuterType<TContext>
  typeAlias: TypeAlias<TContext>
  pick: object
  pick2: object
  pick3: CreateInput2<TContext>
  unknown: LayoutMetadataMap<TContext>
}

export interface MutationResult<TContext = any> {
  result: boolean
}

export interface GetResult<TContext = any> {
  result: Result<TContext>
}

export interface Result<TContext = any> {
  member1: string
  member2(input: { input: string }, context: TContext, info: GraphQLResolveInfo): string | Promise<string>
}

export interface CreateInputMember3<TContext = any> {
  member1: string
}

export type Result2<TContext = any> = Result3<TContext>

export interface Result3<TContext = any> {
  result3: string
}

export interface Pet<TContext = any> {
  id?: number
  name: string
  photoUrls: Array<string>
  status: string
}

export interface MongooseScheme<TContext = any> {
  objectId: ObjectId<TContext>
  date: Date<TContext>
  decimal128: Decimal128<TContext>
  index1: string
  index2: string
  index3: string
  buffer: Buffer<TContext>
}

export interface CreateInput2<TContext = any> {
  member1: string
  member2: number
}

export interface LayoutMetadataMap<TContext = any> {

}

export interface Metadata<TContext = any> {

}

export type WsCommand<TContext = any> = CreateBlog<TContext> | UpdateBlog<TContext>

export interface CreateBlog<TContext = any> {
  type: string
  content: string
}

export interface UpdateBlog<TContext = any> {
  type: string
  id: number
  content: string
}

export type WsPush<TContext = any> = BlogChange<TContext>

export interface BlogChange<TContext = any> {
  type: string
  id: number
  content: string
}

export interface TestController<TContext = any> {
  get(input: { foo: number, bar: string }, context: TContext, info: GraphQLResolveInfo): any | Promise<any>
}

export interface OuterType<TContext = any> {
  outerType: number
}

export interface ResolveResult<TContext = any> {
  create: DeepReturnType<MutationResult<TContext>>
  user: DeepReturnType<GetResult<TContext>>
  users: DeepReturnType<GetResult<TContext>>
}

/* eslint-enable */
// tslint:enable
